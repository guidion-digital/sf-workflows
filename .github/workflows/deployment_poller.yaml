name: Poll Salesforce Deployment Status

on:
  # Scheduled polling - uncomment when ready for production
  # Cron runs in UTC — these cover 8:00–20:00 CET (7:00–19:00 UTC) / CEST (6:00–18:00 UTC)
  # schedule:
  #   - cron: '*/10 6-19 * * 1-5'
  
  # Manual trigger for testing
  workflow_dispatch:

# Permissions needed to read/delete artifacts
permissions:
  actions: write    # Required to delete artifacts
  contents: read    # Required to access repo

jobs:
  poll-deployments:
    runs-on: ubuntu-latest
    # Note: Not using salesforce/cli container because we need gh CLI and unzip
    steps:
      - name: Find pending deployment artifacts
        id: find_artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Searching for pending deployment artifacts..."
          
          # List all artifacts matching our naming pattern (fetch up to 100)
          ARTIFACTS=$(gh api "repos/${{ github.repository }}/actions/artifacts?per_page=100" \
            --jq '.artifacts[] | select(.name | startswith("pending-deployment-")) | {id: .id, name: .name, run_id: (.name | split("-") | .[-1])}')
          
          if [ -z "$ARTIFACTS" ]; then
            echo "No pending deployments found."
            echo "has_pending=false" >> "$GITHUB_OUTPUT"
          else
            echo "Found pending deployments:"
            echo "$ARTIFACTS" | jq -s '.'
            echo "$ARTIFACTS" | jq -s '.' > artifacts.json
            echo "has_pending=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Install Salesforce CLI
        if: steps.find_artifacts.outputs.has_pending == 'true'
        run: npm install -g @salesforce/cli

      - name: Checkout slack-notifications
        if: steps.find_artifacts.outputs.has_pending == 'true'
        uses: actions/checkout@v4
        with:
          repository: guidion-digital/slack-notifications
          ref: v2
          path: slack-notifications

      - name: Install slack_sdk
        if: steps.find_artifacts.outputs.has_pending == 'true'
        run: pip install slack_sdk

      - name: Process pending deployments
        if: steps.find_artifacts.outputs.has_pending == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
          # SF credentials for each environment
          SF_LOGIN_URL_DEV: ${{ vars.SF_LOGIN_URL_DEV }}
          SF_USERNAME_DEV: ${{ vars.SF_USERNAME_DEV }}
          SF_CLIENT_ID_DEV: ${{ vars.SF_CLIENT_ID_DEV }}
          SF_CLIENT_KEY_DEV: ${{ secrets.SF_CLIENT_KEY_DEV }}
          SF_LOGIN_URL_ACC: ${{ vars.SF_LOGIN_URL_ACC }}
          SF_USERNAME_ACC: ${{ vars.SF_USERNAME_ACC }}
          SF_CLIENT_ID_ACC: ${{ vars.SF_CLIENT_ID_ACC }}
          SF_CLIENT_KEY_ACC: ${{ secrets.SF_CLIENT_KEY_ACC }}
          SF_LOGIN_URL_PROD: ${{ vars.SF_LOGIN_URL_PROD }}
          SF_USERNAME_PROD: ${{ vars.SF_USERNAME_PROD }}
          SF_CLIENT_ID_PROD: ${{ vars.SF_CLIENT_ID_PROD }}
          SF_CLIENT_KEY_PROD: ${{ secrets.SF_CLIENT_KEY_PROD }}
          # SF base URLs per environment (for deployment status links)
          SF_BASE_URL_DEV: ${{ vars.SF_BASE_URL_DEV }}
          SF_BASE_URL_ACC: ${{ vars.SF_BASE_URL_ACC }}
          SF_BASE_URL_PROD: ${{ vars.SF_BASE_URL_PROD }}
          # Cache flush
          CACHE_FLUSH_API_KEY: ${{ secrets.CACHE_FLUSH_API_KEY }}
          USER_ID_FOR_CACHE_FLUSH: ${{ vars.USER_ID_FOR_CACHE_FLUSH }}
        run: |
          # Notification helper — calls the same notify.py used by the slack-notifications action.
          # Uses export so that multi-line strings (e.g. error details) are passed safely.
          send_notification() {
            export MESSAGE_TYPE="deployment"
            export DEPLOYMENT_STATUS="$1"
            export SLACK_CHANNEL
            export ENVIRONMENT
            export BRANCH
            export COMMIT_URL
            export WORKFLOW_USER="$ACTOR"
            export WORKFLOW_URL="$GITHUB_RUN_URL"
            export SF_DEPLOY_URL="$SF_DEPLOY_STATUS_URL"
            export ERROR_DETAILS="${2:-}"
            python3 slack-notifications/notify.py
          }

          # Process each artifact (using while read to handle JSON safely)
          cat artifacts.json | jq -c '.[]' | while read -r ARTIFACT_ROW; do
            ARTIFACT_ID=$(echo "$ARTIFACT_ROW" | jq -r '.id')
            ARTIFACT_NAME=$(echo "$ARTIFACT_ROW" | jq -r '.name')
            
            echo "=========================================="
            echo "Processing artifact: $ARTIFACT_NAME (ID: $ARTIFACT_ID)"
            echo "=========================================="
            
            # Download the artifact
            mkdir -p artifact_temp
            gh api "repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip" > artifact.zip
            unzip -o artifact.zip -d artifact_temp
            
            # Read deployment info
            DEPLOYMENT_INFO=$(cat artifact_temp/deployment-info.json)
            echo "Deployment info:"
            echo "$DEPLOYMENT_INFO" | jq '.'
            
            JOB_ID=$(echo "$DEPLOYMENT_INFO" | jq -r '.job_id')
            ENVIRONMENT=$(echo "$DEPLOYMENT_INFO" | jq -r '.environment')
            ENV_UPPER=$(echo "$ENVIRONMENT" | tr '[:lower:]' '[:upper:]')
            TARGET_ORG=$(echo "$DEPLOYMENT_INFO" | jq -r '.target_org')
            SLACK_CHANNEL=$(echo "$DEPLOYMENT_INFO" | jq -r '.slack_channel')
            COMMIT_SHA=$(echo "$DEPLOYMENT_INFO" | jq -r '.commit_sha')
            BRANCH=$(echo "$DEPLOYMENT_INFO" | jq -r '.branch')
            ACTOR=$(echo "$DEPLOYMENT_INFO" | jq -r '.actor')
            GITHUB_RUN_URL=$(echo "$DEPLOYMENT_INFO" | jq -r '.github_run_url')
            STARTED_AT=$(echo "$DEPLOYMENT_INFO" | jq -r '.started_at')
            SOURCE_REPO=$(echo "$DEPLOYMENT_INFO" | jq -r '.github_repository // empty')
            SOURCE_SERVER=$(echo "$DEPLOYMENT_INFO" | jq -r '.github_server_url // empty')
            
            # Build commit URL using source repo (fix for cross-repo deployments)
            if [ -n "$SOURCE_REPO" ] && [ -n "$SOURCE_SERVER" ]; then
              COMMIT_URL="${SOURCE_SERVER}/${SOURCE_REPO}/commit/$COMMIT_SHA"
            else
              COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/$COMMIT_SHA"
            fi
            
            # Build SF deploy status URL
            SF_BASE_URL_VAR="SF_BASE_URL_${ENV_UPPER}"
            SF_BASE_URL="${!SF_BASE_URL_VAR}"
            if [ -n "$SF_BASE_URL" ]; then
              SF_DEPLOY_STATUS_URL="${SF_BASE_URL}/changemgmt/monitorDeploymentsDetails.apexp?asyncId=${JOB_ID}"
            else
              SF_DEPLOY_STATUS_URL=""
            fi
            
            # Check if deployment is stale (older than 6 hours)
            STARTED_EPOCH=$(date -d "$STARTED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$STARTED_AT" +%s 2>/dev/null || echo "0")
            NOW_EPOCH=$(date +%s)
            AGE_HOURS=$(( (NOW_EPOCH - STARTED_EPOCH) / 3600 ))
            
            if [ "$AGE_HOURS" -gt 6 ]; then
              echo "WARNING: Deployment is $AGE_HOURS hours old. Marking as stale."
              send_notification "stale" "Deployment started $AGE_HOURS hours ago and never completed. Job ID: $JOB_ID. This artifact will be removed." || echo "WARNING: Slack notification failed (non-critical)"
              
              # Delete the stale artifact
              gh api --method DELETE "repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}" || echo "Failed to delete artifact"
              rm -rf artifact_temp artifact.zip
              continue
            fi
            
            # Get environment-specific credentials
            SF_LOGIN_URL_VAR="SF_LOGIN_URL_${ENV_UPPER}"
            SF_USERNAME_VAR="SF_USERNAME_${ENV_UPPER}"
            SF_CLIENT_ID_VAR="SF_CLIENT_ID_${ENV_UPPER}"
            SF_CLIENT_KEY_VAR="SF_CLIENT_KEY_${ENV_UPPER}"
            
            SF_LOGIN_URL="${!SF_LOGIN_URL_VAR}"
            SF_USERNAME="${!SF_USERNAME_VAR}"
            SF_CLIENT_ID="${!SF_CLIENT_ID_VAR}"
            SF_CLIENT_KEY="${!SF_CLIENT_KEY_VAR}"
            
            if [ -z "$SF_LOGIN_URL" ] || [ -z "$SF_USERNAME" ] || [ -z "$SF_CLIENT_ID" ] || [ -z "$SF_CLIENT_KEY" ]; then
              echo "ERROR: Missing SF credentials for environment: $ENVIRONMENT"
              continue
            fi
            
            # Authenticate to Salesforce
            echo "Authenticating to Salesforce ($ENVIRONMENT)..."
            printf '%s' "$SF_CLIENT_KEY" | base64 -d > jwt-key.key
            if ! sf org login jwt \
              --instance-url "$SF_LOGIN_URL" \
              --username "$SF_USERNAME" \
              --client-id "$SF_CLIENT_ID" \
              --jwt-key-file jwt-key.key \
              --alias "$TARGET_ORG"; then
              echo "ERROR: Failed to authenticate to Salesforce for environment: $ENVIRONMENT"
              rm -f jwt-key.key
              rm -rf artifact_temp artifact.zip
              continue
            fi
            rm jwt-key.key
            
            # Check deployment status
            echo "Checking deployment status for Job ID: $JOB_ID"
            DEPLOY_STATUS=$(sf project deploy report --job-id "$JOB_ID" --target-org "$TARGET_ORG" --json 2>&1) || true
            
            STATUS=$(echo "$DEPLOY_STATUS" | jq -r '.result.status // .status // "Unknown"')
            echo "Deployment status: $STATUS"
            
            # Handle completed deployments
            if [[ "$STATUS" == "Succeeded" ]]; then
              echo "Deployment SUCCEEDED!"
              send_notification "succeeded" || echo "WARNING: Slack notification failed (non-critical)"
              
              # Flush cache (only for acc and prod)
              if [[ "$ENVIRONMENT" == "acc" ]]; then
                echo "Flushing cache for acc environment..."
                curl -s -X POST https://homeapp.web.acc.guidion.io/api/v1/cache-flush \
                  -H "Content-Type: application/json" \
                  -H "x-api-key: $CACHE_FLUSH_API_KEY" \
                  -d "{\"userId\": \"$USER_ID_FOR_CACHE_FLUSH\"}" || echo "Cache flush failed (non-critical)"
              elif [[ "$ENVIRONMENT" == "prod" ]]; then
                echo "Flushing cache for prod environment..."
                curl -s -X POST https://homeapp.guidion.io/api/v1/cache-flush \
                  -H "Content-Type: application/json" \
                  -H "x-api-key: $CACHE_FLUSH_API_KEY" \
                  -d "{\"userId\": \"$USER_ID_FOR_CACHE_FLUSH\"}" || echo "Cache flush failed (non-critical)"
              fi
              
              # Delete the artifact (deployment is done)
              echo "Deleting artifact..."
              gh api --method DELETE "repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}" || echo "Failed to delete artifact"
              
            elif [[ "$STATUS" == "Canceled" ]]; then
              echo "Deployment was CANCELED by user. Skipping Slack notification."
              
              # Delete the artifact (deployment is done)
              echo "Deleting artifact..."
              gh api --method DELETE "repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}" || echo "Failed to delete artifact"
              
            elif [[ "$STATUS" == "Failed" ]]; then
              echo "Deployment FAILED!"
              
              # Get comprehensive error details from the deploy report
              COMPONENT_FAILURES=$(echo "$DEPLOY_STATUS" | jq -r '
                (.result.details.componentFailures // []) |
                if type == "array" then .[] else . end |
                "• \(.componentType): \(.fullName) - \(.problem // "unknown error")"
                ' 2>/dev/null | head -10)
              
              TEST_FAILURES=$(echo "$DEPLOY_STATUS" | jq -r '
                (.result.details.runTestResult.failures // []) |
                if type == "array" then .[] else . end |
                "• \(.name).\(.methodName): \(.message // "test failed")"
                ' 2>/dev/null | head -5)
              
              GENERAL_ERROR=$(echo "$DEPLOY_STATUS" | jq -r '.result.errorMessage // .message // empty' 2>/dev/null)
              
              # Build error message
              ERROR_MESSAGE=""
              if [ -n "$COMPONENT_FAILURES" ]; then
                ERROR_MESSAGE="Component Failures:\n$COMPONENT_FAILURES"
              fi
              if [ -n "$TEST_FAILURES" ]; then
                [ -n "$ERROR_MESSAGE" ] && ERROR_MESSAGE="$ERROR_MESSAGE\n\n"
                ERROR_MESSAGE="${ERROR_MESSAGE}Test Failures:\n$TEST_FAILURES"
              fi
              if [ -n "$GENERAL_ERROR" ] && [ "$GENERAL_ERROR" != "null" ]; then
                [ -n "$ERROR_MESSAGE" ] && ERROR_MESSAGE="$ERROR_MESSAGE\n\n"
                ERROR_MESSAGE="${ERROR_MESSAGE}$GENERAL_ERROR"
              fi
              
              # Fallback if no specific errors found
              if [ -z "$ERROR_MESSAGE" ]; then
                ERROR_MESSAGE="No specific error details available. Check Salesforce deployment status for more info."
              fi
              
              # Limit length (Python/slack_sdk handles JSON encoding)
              ERROR_MESSAGE=$(echo -e "$ERROR_MESSAGE" | head -c 1500)
              
              send_notification "failed" "$ERROR_MESSAGE" || echo "WARNING: Slack notification failed (non-critical)"
              
              # Delete the artifact (deployment is done, even if failed)
              echo "Deleting artifact..."
              gh api --method DELETE "repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}" || echo "Failed to delete artifact"
              
            else
              echo "Deployment still in progress ($STATUS). Will check again in next poll."
            fi
            
            # Cleanup
            rm -rf artifact_temp artifact.zip
            
          done
          
          echo "=========================================="
          echo "Polling complete."
          echo "=========================================="
